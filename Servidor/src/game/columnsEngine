const crypto = require("crypto");

// Mapeo con NodeGrid.Node.JewelType (cliente C#)
const Jewel = {
  None: 0,
  Red: 1,
  Green: 2,
  Blue: 3,
  Yellow: 4,
  Orange: 5,
  Purple: 6,
  Shiny: 7,
};
const JEWELS = [Jewel.Red, Jewel.Green, Jewel.Blue, Jewel.Yellow, Jewel.Orange, Jewel.Purple];

class ColumnsEngine {
  constructor(opts) {
    opts = opts || {};
    this.sizeX = Number(opts.sizeX || 6);
    this.sizeY = Number(opts.sizeY || 12);
    this.tickMs = Number(opts.tickMs || 500);
    this.seed = opts.seed || crypto.randomBytes(8).toString("hex");
    this._rng = this._mulberry32(this._hashSeed(this.seed));
    this.grid = this._createEmptyGrid();
    this._interval = null;

    // Replay hooks
    this.replay = { seq: 0, onRecord: null };

    // Callbacks al exterior
    this.onSetup = null;   // function(setupObj)
    this.onUpdate = null;  // function(updateObj)
    this.onEnd = null;     // function()
  }

  _hashSeed(seed) {
    return seed.split("").reduce((a, c) => (a + c.charCodeAt(0)) >>> 0, 0) || 1;
  }
  _mulberry32(a) {
    return function () {
      a |= 0; a = a + 0x6D2B79F5 | 0;
      let t = Math.imul(a ^ a >>> 15, 1 | a);
      t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }

  _createEmptyGrid() {
    const g = [];
    for (let x = 0; x < this.sizeX; x++) {
      const col = [];
      for (let y = 0; y < this.sizeY; y++) col.push(Jewel.None);
      g.push(col);
    }
    return g;
  }

  getSetupGrid(meta) {
    meta = meta || {};
    return {
      playerId: Number(meta.playerId || 0),
      playerName: String(meta.playerName || "P1"),
      sizeX: this.sizeX,
      sizeY: this.sizeY,
    };
  }

  step() {
    // Demo: cae una gema en una columna aleatoria y limpia trÃ­os verticales
    const col = Math.floor(this._rng() * this.sizeX);
    for (let y = this.sizeY - 1; y >= 0; y--) {
      if (this.grid[col][y] === Jewel.None) {
        this.grid[col][y] = JEWELS[Math.floor(this._rng() * JEWELS.length)];
        break;
      }
    }

    const toClear = [];
    for (let x = 0; x < this.sizeX; x++) {
      for (let y = 0; y <= this.sizeY - 3; y++) {
        const a = this.grid[x][y], b = this.grid[x][y + 1], c = this.grid[x][y + 2];
        if (a !== Jewel.None && a === b && b === c) {
          toClear.push({ x, y }, { x, y: y + 1 }, { x, y: y + 2 });
        }
      }
    }
    toClear.forEach(({ x, y }) => this.grid[x][y] = Jewel.None);

    for (let x = 0; x < this.sizeX; x++) {
      const stack = this.grid[x].filter(v => v !== Jewel.None);
      while (stack.length < this.sizeY) stack.unshift(Jewel.None);
      this.grid[x] = stack;
    }

    const updatedNodes = [];
    for (let y = 0; y < this.sizeY; y++) {
      updatedNodes.push({ type: this.grid[col][y], x: col, y });
    }
    toClear.forEach(({ x, y }) => updatedNodes.push({ type: Jewel.None, x, y }));

    return {
      playerId: 0,
      playerName: "P1",
      updatedNodes,
    };
  }

  start() {
    const setup = this.getSetupGrid();
    if (this.onSetup) this.onSetup(setup);
    this._record("GRID_SETUP", setup);

    const self = this;
    this._interval = setInterval(function () {
      const update = self.step();
      if (self.onUpdate) self.onUpdate(update);
      self._record("GRID_UPDATE", update);
    }, this.tickMs);
  }

  stop() {
    if (this._interval) {
      clearInterval(this._interval);
      this._interval = null;
    }
    if (this.onEnd) this.onEnd();
  }

  _record(type, payload) {
    const cb = this.replay && this.replay.onRecord;
    if (!cb) return;
    this.replay.seq++;
    cb({ type: type, payload: payload, seq: this.replay.seq });
  }
}

module.exports = { ColumnsEngine, Jewel };